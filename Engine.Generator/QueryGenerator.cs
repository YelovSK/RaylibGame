using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Engine.Generator;

// Vibe-coded, no idea how it works.
[Generator]
public class EcsQueryGenerator : IIncrementalGenerator
{
    private const int MaxInclude = 3;
    private const int MaxExclude = 3;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Generate the main query methods on World class
            ctx.AddSource("World.Query.g.cs", GenerateWorldQueryMethods());
            
            // Generate QueryBuilder structs
            ctx.AddSource("QueryBuilder.g.cs", GenerateQueryBuilders());
            
            // Generate QueryBuilderExclude structs
            ctx.AddSource("QueryBuilderExclude.g.cs", GenerateQueryBuildersExclude());
        });
    }

    private static string GenerateWorldQueryMethods()
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Engine;");
        sb.AppendLine();
        
        // Generate Delegates
        for (int arity = 1; arity <= MaxInclude; arity++)
        {
            sb.AppendLine(GenerateDelegate(arity));
        }
        sb.AppendLine();

        sb.AppendLine("public partial class World");
        sb.AppendLine("{");
        
        // Generate View<T1>(), View<T1, T2>(), etc.
        for (int arity = 1; arity <= MaxInclude; arity++)
        {
            var typeParams = string.Join(", ", Enumerable.Range(1, arity).Select(i => $"T{i}"));
            var constraints = string.Join(" ", Enumerable.Range(1, arity).Select(i => $"where T{i} : struct"));
            
            sb.AppendLine($"    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"    public QueryBuilder<{typeParams}> View<{typeParams}>() {constraints}");
            sb.AppendLine("    {");
            sb.AppendLine($"        return new QueryBuilder<{typeParams}>(this);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    private static string GenerateDelegate(int arity)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, arity).Select(i => $"T{i}"));
        var methodParams = "Entity entity" + string.Concat(Enumerable.Range(1, arity).Select(i => $", ref T{i} c{i}"));
        return $"public delegate void QueryCallback<{typeParams}>({methodParams});";
    }

    private static string GenerateQueryBuilders()
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Engine;");
        sb.AppendLine();
        
        // Generate QueryBuilder for each arity
        for (int includeArity = 1; includeArity <= MaxInclude; includeArity++)
        {
            sb.AppendLine(GenerateQueryBuilder(includeArity));
        }
        
        return sb.ToString();
    }

    private static string GenerateQueryBuilder(int includeArity)
    {
        var sb = new StringBuilder();
        
        var typeParams = string.Join(", ", Enumerable.Range(1, includeArity).Select(i => $"T{i}"));
        var constraints = string.Join(" ", Enumerable.Range(1, includeArity).Select(i => $"where T{i} : struct"));
        
        sb.AppendLine($"public readonly ref struct QueryBuilder<{typeParams}> {constraints}");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly World _world;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public QueryBuilder(World world)");
        sb.AppendLine("    {");
        sb.AppendLine("        _world = world;");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Generate Without<E1>(), Without<E1, E2>(), etc.
        for (int excludeArity = 1; excludeArity <= MaxExclude; excludeArity++)
        {
            var excludeTypeParams = string.Join(", ", Enumerable.Range(1, excludeArity).Select(i => $"E{i}"));
            var excludeConstraints = string.Join(" ", Enumerable.Range(1, excludeArity).Select(i => $"where E{i} : struct"));
            var allTypeParams = $"{typeParams}, {excludeTypeParams}";
            
            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            // Return specific struct name
            sb.AppendLine($"    public QueryBuilderExclude_{includeArity}_{excludeArity}<{allTypeParams}> Without<{excludeTypeParams}>() {excludeConstraints}");
            sb.AppendLine("    {");
            sb.AppendLine($"        return new QueryBuilderExclude_{includeArity}_{excludeArity}<{allTypeParams}>(_world);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        
        // Generate ForEach method (no exclusions)
        sb.AppendLine(GenerateForEachMethod(includeArity, 0));
        
        sb.AppendLine("}");
        sb.AppendLine();
        
        return sb.ToString();
    }

    private static string GenerateQueryBuildersExclude()
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Engine;");
        sb.AppendLine();
        
        // Generate QueryBuilderExclude for each combination
        for (int includeArity = 1; includeArity <= MaxInclude; includeArity++)
        {
            for (int excludeArity = 1; excludeArity <= MaxExclude; excludeArity++)
            {
                sb.AppendLine(GenerateQueryBuilderExclude(includeArity, excludeArity));
            }
        }
        
        return sb.ToString();
    }

    private static string GenerateQueryBuilderExclude(int includeArity, int excludeArity)
    {
        var sb = new StringBuilder();
        
        var includeTypeParams = string.Join(", ", Enumerable.Range(1, includeArity).Select(i => $"T{i}"));
        var excludeTypeParams = string.Join(", ", Enumerable.Range(1, excludeArity).Select(i => $"E{i}"));
        var allTypeParams = $"{includeTypeParams}, {excludeTypeParams}";
        
        var includeConstraints = string.Join(" ", Enumerable.Range(1, includeArity).Select(i => $"where T{i} : struct"));
        var excludeConstraints = string.Join(" ", Enumerable.Range(1, excludeArity).Select(i => $"where E{i} : struct"));
        var allConstraints = $"{includeConstraints} {excludeConstraints}";
        
        // Name class with suffixes
        sb.AppendLine($"public readonly ref struct QueryBuilderExclude_{includeArity}_{excludeArity}<{allTypeParams}> {allConstraints}");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly World _world;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public QueryBuilderExclude_{includeArity}_{excludeArity}(World world)");
        sb.AppendLine("    {");
        sb.AppendLine("        _world = world;");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Generate ForEach method with exclusions
        sb.AppendLine(GenerateForEachMethod(includeArity, excludeArity));
        
        sb.AppendLine("}");
        sb.AppendLine();
        
        return sb.ToString();
    }

    private static string GenerateForEachMethod(int includeArity, int excludeArity)
    {
        var sb = new StringBuilder();
        
        var includeTypeParams = string.Join(", ", Enumerable.Range(1, includeArity).Select(i => $"T{i}"));
        // Use QueryCallback<T1, T2,...> instead of Action
        
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public void ForEach(QueryCallback<{includeTypeParams}> action)");
        sb.AppendLine("    {");
        
        // Get all component sets
        for (int i = 1; i <= includeArity; i++)
        {
            sb.AppendLine($"        var set{i} = _world.GetPool<T{i}>();");
        }
        
        for (int i = 1; i <= excludeArity; i++)
        {
            sb.AppendLine($"        var excludeSet{i} = _world.GetPool<E{i}>();");
        }
        
        // Find smallest included set
        sb.AppendLine();
        sb.AppendLine("        var minCount = set1.Count;");
        sb.AppendLine("        var minSet = 1;");
        
        for (int i = 2; i <= includeArity; i++)
        {
            sb.AppendLine($"        if (set{i}.Count < minCount) {{ minCount = set{i}.Count; minSet = {i}; }}");
        }
        
        sb.AppendLine();
        sb.AppendLine("        if (minCount == 0) return;");
        sb.AppendLine();
        
        // Generate switch for iterating smallest set
        sb.AppendLine("        switch (minSet)");
        sb.AppendLine("        {");
        
        for (int minSetIdx = 1; minSetIdx <= includeArity; minSetIdx++)
        {
            sb.AppendLine($"            case {minSetIdx}:");
            sb.AppendLine("                {");
            sb.AppendLine($"                    var entities = set{minSetIdx}.DenseEntities;");
            
            // Hoist ALL Spans here
            for (int k = 1; k <= includeArity; k++)
            {
               sb.AppendLine($"                    var span{k} = set{k}.AsSpan();");
            }

            sb.AppendLine("                    for (int i = 0; i < entities.Count; i++)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        var entity = entities[i];");
            
            // Check exclusions FIRST
            for (int j = 1; j <= excludeArity; j++)
            {
                sb.AppendLine($"                        if (excludeSet{j}.Contains(entity)) continue;");
            }
            
            // Check other included components and capture indices
            var indicesDict = new System.Collections.Generic.Dictionary<int, string>();
            
            for (int j = 1; j <= includeArity; j++)
            {
                if (j == minSetIdx) continue;
                
                var indexVar = $"index{j}";
                // Use GetDenseIndex to check existence AND get access index
                sb.AppendLine($"                        var {indexVar} = set{j}.GetDenseIndex(entity.Id);");
                sb.AppendLine($"                        if ({indexVar} == -1) continue;");
                
                indicesDict[j] = indexVar;
            }
            
            // Get refs to all components using PRE-CALCULATED Spans
            for (int j = 1; j <= includeArity; j++)
            {
                if (j == minSetIdx)
                {
                    sb.AppendLine($"                        ref var c{j} = ref span{j}[i];");
                }
                else
                {
                    var indexVar = indicesDict[j];
                    sb.AppendLine($"                        ref var c{j} = ref span{j}[{indexVar}];");
                }
            }
            
            // Call action
            var actionArgs = "entity" + string.Concat(Enumerable.Range(1, includeArity).Select(i => $", ref c{i}"));
            sb.AppendLine($"                        action({actionArgs});");
            
            sb.AppendLine("                    }");
            sb.AppendLine("                    break;");
            sb.AppendLine("                }");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        
        return sb.ToString();
    }
}